$date
	Sat Feb  4 02:44:58 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module carry_look_ahead_adder_tb $end
$var wire 8 ! result_8 [7:0] $end
$var wire 64 " result_64 [63:0] $end
$var wire 32 # result_32 [31:0] $end
$var wire 16 $ result_16 [15:0] $end
$var wire 128 % result_128 [127:0] $end
$var wire 4 & result [3:0] $end
$var wire 1 ' carryout_8 $end
$var wire 1 ( carryout_64 $end
$var wire 1 ) carryout_32 $end
$var wire 1 * carryout_16 $end
$var wire 1 + carryout_128 $end
$var wire 1 , carryout $end
$var reg 4 - A [3:0] $end
$var reg 128 . A_128 [127:0] $end
$var reg 16 / A_16 [15:0] $end
$var reg 32 0 A_32 [31:0] $end
$var reg 64 1 A_64 [63:0] $end
$var reg 8 2 A_8 [7:0] $end
$var reg 4 3 B [3:0] $end
$var reg 128 4 B_128 [127:0] $end
$var reg 16 5 B_16 [15:0] $end
$var reg 32 6 B_32 [31:0] $end
$var reg 64 7 B_64 [63:0] $end
$var reg 8 8 B_8 [7:0] $end
$var reg 1 9 clk $end
$var reg 4 : expected_result [3:0] $end
$var reg 128 ; expected_result_128 [127:0] $end
$var reg 16 < expected_result_16 [15:0] $end
$var reg 32 = expected_result_32 [31:0] $end
$var reg 64 > expected_result_64 [63:0] $end
$var reg 8 ? expected_result_8 [7:0] $end
$var reg 1 @ reset $end
$var integer 32 A failedTests [31:0] $end
$var integer 32 B totalTests [31:0] $end
$scope module BitAdder128 $end
$var wire 128 C A [127:0] $end
$var wire 128 D B [127:0] $end
$var wire 1 E carryin $end
$var reg 1 + carryout $end
$var reg 128 F result [127:0] $end
$upscope $end
$scope module BitAdder16 $end
$var wire 16 G A [15:0] $end
$var wire 16 H B [15:0] $end
$var wire 1 I carryin $end
$var reg 1 * carryout $end
$var reg 16 J result [15:0] $end
$upscope $end
$scope module BitAdder32 $end
$var wire 32 K A [31:0] $end
$var wire 32 L B [31:0] $end
$var wire 1 M carryin $end
$var reg 1 ) carryout $end
$var reg 32 N result [31:0] $end
$upscope $end
$scope module BitAdder64 $end
$var wire 64 O A [63:0] $end
$var wire 64 P B [63:0] $end
$var wire 1 Q carryin $end
$var reg 1 ( carryout $end
$var reg 64 R result [63:0] $end
$upscope $end
$scope module BitAdder8 $end
$var wire 8 S A [7:0] $end
$var wire 8 T B [7:0] $end
$var wire 1 U carryin $end
$var reg 1 ' carryout $end
$var reg 8 V result [7:0] $end
$upscope $end
$scope module uut $end
$var wire 4 W A [3:0] $end
$var wire 4 X B [3:0] $end
$var wire 1 Y carryin $end
$var reg 1 , carryout $end
$var reg 4 Z result [3:0] $end
$upscope $end
$upscope $end
$scope module carry_look_ahead_logic $end
$var wire 1 [ c_in $end
$var wire 4 \ g [3:0] $end
$var wire 4 ] p [3:0] $end
$var reg 5 ^ c [4:0] $end
$upscope $end
$scope module slow_and $end
$var wire 2 _ a [1:0] $end
$var wire 1 ` result $end
$upscope $end
$scope module slow_or $end
$var wire 2 a a [1:0] $end
$var wire 1 b result $end
$upscope $end
$scope module slow_xor $end
$var wire 2 c a [1:0] $end
$var wire 1 d result $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
xd
bz c
xb
bz a
x`
bz _
bx ^
bz ]
bz \
z[
bx Z
0Y
bx X
bx W
bx V
0U
bx T
bx S
bx R
0Q
bx P
bx O
bx N
0M
bx L
bx K
bx J
0I
bx H
bx G
bx F
0E
bx D
bx C
b0 B
b0 A
1@
bx ?
bx >
bx =
bx <
bx ;
bx :
09
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
x,
x+
x*
x)
x(
x'
bx &
bx %
bx $
bx #
bx "
bx !
$end
#50000
19
#100000
0@
09
#150000
19
#160000
b0 :
b0 3
b0 X
b0 -
b0 W
b1 B
#200000
09
#250000
19
#260000
b1 A
#270000
b1000 :
b1 3
b1 X
b111 -
b111 W
b10 B
#300000
09
#350000
19
#370000
b10 A
#380000
b0 :
b1111 -
b1111 W
b11 B
#400000
09
#450000
19
#480000
b11 A
#490000
b1110 :
b10 3
b10 X
b1100 -
b1100 W
b100 B
#500000
09
#550000
19
#590000
b100 A
#600000
b10 :
b110 3
b110 X
b101 B
09
#650000
19
#700000
09
b101 A
#710000
b0 ?
b0 8
b0 T
b0 2
b0 S
b110 B
#750000
19
#800000
09
#810000
b110 A
#820000
b1 8
b1 T
b11111111 2
b11111111 S
b111 B
#850000
19
#900000
09
#920000
b111 A
#930000
b10110 ?
b1011 8
b1011 T
b1011 2
b1011 S
b1000 B
#950000
19
#1000000
09
#1030000
b1000 A
#1040000
b111001 ?
b1100100 8
b1100100 T
b11010101 2
b11010101 S
b1001 B
#1050000
19
#1100000
09
#1140000
b1001 A
#1150000
b0 <
b1 5
b1 H
b1111111111111111 /
b1111111111111111 G
b1010 B
19
#1200000
09
#1250000
19
b1010 A
#1260000
b0 =
b1 6
b1 L
b11111111111111111111111111111111 0
b11111111111111111111111111111111 K
b1011 B
#1300000
09
#1350000
19
#1360000
b1011 A
#1370000
b0 >
b1 7
b1 P
b1111111111111111111111111111111111111111111111111111111111111111 1
b1111111111111111111111111111111111111111111111111111111111111111 O
b1100 B
#1400000
09
#1450000
19
#1470000
b1100 A
#1480000
b0 ;
b1 4
b1 D
b11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 .
b11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 C
b1101 B
#1500000
09
#1550000
19
#1580000
b1101 A
#1590000
