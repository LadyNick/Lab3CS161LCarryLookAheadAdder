$date
	Fri Feb  3 23:23:34 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module carry_look_ahead_adder_tb $end
$var wire 64 ! result_64 [63:0] $end
$var wire 32 " result_32 [31:0] $end
$var wire 16 # result_16 [15:0] $end
$var wire 128 $ result_128 [127:0] $end
$var wire 4 % result [3:0] $end
$var wire 1 & carryout_64 $end
$var wire 1 ' carryout_32 $end
$var wire 1 ( carryout_16 $end
$var wire 1 ) carryout_128 $end
$var wire 1 * carryout $end
$var reg 4 + A [3:0] $end
$var reg 128 , A_128 [127:0] $end
$var reg 16 - A_16 [15:0] $end
$var reg 32 . A_32 [31:0] $end
$var reg 64 / A_64 [63:0] $end
$var reg 4 0 B [3:0] $end
$var reg 128 1 B_128 [127:0] $end
$var reg 16 2 B_16 [15:0] $end
$var reg 32 3 B_32 [31:0] $end
$var reg 64 4 B_64 [63:0] $end
$var reg 1 5 clk $end
$var reg 4 6 expected_result [3:0] $end
$var reg 128 7 expected_result_128 [127:0] $end
$var reg 16 8 expected_result_16 [15:0] $end
$var reg 32 9 expected_result_32 [31:0] $end
$var reg 64 : expected_result_64 [63:0] $end
$var reg 1 ; reset $end
$var integer 32 < failedTests [31:0] $end
$var integer 32 = totalTests [31:0] $end
$scope module BitAdder128 $end
$var wire 128 > A [127:0] $end
$var wire 128 ? B [127:0] $end
$var wire 1 @ carryin $end
$var reg 1 ) carryout $end
$var reg 128 A result [127:0] $end
$upscope $end
$scope module BitAdder16 $end
$var wire 16 B A [15:0] $end
$var wire 16 C B [15:0] $end
$var wire 1 D carryin $end
$var reg 1 ( carryout $end
$var reg 16 E result [15:0] $end
$upscope $end
$scope module BitAdder32 $end
$var wire 32 F A [31:0] $end
$var wire 32 G B [31:0] $end
$var wire 1 H carryin $end
$var reg 1 ' carryout $end
$var reg 32 I result [31:0] $end
$upscope $end
$scope module BitAdder64 $end
$var wire 64 J A [63:0] $end
$var wire 64 K B [63:0] $end
$var wire 1 L carryin $end
$var reg 1 & carryout $end
$var reg 64 M result [63:0] $end
$upscope $end
$scope module uut $end
$var wire 4 N A [3:0] $end
$var wire 4 O B [3:0] $end
$var wire 1 P carryin $end
$var reg 1 * carryout $end
$var reg 4 Q result [3:0] $end
$upscope $end
$upscope $end
$scope module carry_look_ahead_logic $end
$var wire 1 R c_in $end
$var wire 4 S g [3:0] $end
$var wire 4 T p [3:0] $end
$var reg 5 U c [4:0] $end
$upscope $end
$scope module half_adder_tb $end
$var wire 1 V result $end
$var wire 1 W carryout $end
$var reg 1 X A $end
$var reg 1 Y B $end
$var reg 1 Z clk $end
$var reg 1 [ expected_result $end
$var reg 1 \ reset $end
$var integer 32 ] failedTests [31:0] $end
$var integer 32 ^ totalTests [31:0] $end
$scope module uut $end
$var wire 1 X a $end
$var wire 1 Y b $end
$var wire 1 _ s_w $end
$var wire 1 ` c_out_w $end
$var reg 1 W c_out $end
$var reg 1 V s $end
$scope module and1 $end
$var wire 2 a a [1:0] $end
$var wire 1 ` result $end
$upscope $end
$scope module xor1 $end
$var wire 2 b a [1:0] $end
$var wire 1 _ result $end
$upscope $end
$upscope $end
$upscope $end
$scope module slow_or $end
$var wire 2 c a [1:0] $end
$var wire 1 d result $end
$upscope $end
$scope module spg_block $end
$var wire 1 e a $end
$var wire 1 f b $end
$var wire 1 g c_in $end
$var wire 1 h s_w $end
$var wire 1 i p_w $end
$var wire 1 j g_w $end
$var reg 1 k g $end
$var reg 1 l p $end
$var reg 1 m s $end
$scope module ha1 $end
$var wire 1 e a $end
$var wire 1 f b $end
$var wire 1 n s_w $end
$var wire 1 o c_out_w $end
$var reg 1 j c_out $end
$var reg 1 i s $end
$scope module and1 $end
$var wire 2 p a [1:0] $end
$var wire 1 o result $end
$upscope $end
$scope module xor1 $end
$var wire 2 q a [1:0] $end
$var wire 1 n result $end
$upscope $end
$upscope $end
$scope module xor1 $end
$var wire 2 r a [1:0] $end
$var wire 1 h result $end
$upscope $end
$upscope $end
$scope module carry_look_ahead_adder_tb $end
$scope module BitAdder128 $end
$upscope $end
$scope module BitAdder16 $end
$upscope $end
$scope module BitAdder32 $end
$upscope $end
$scope module BitAdder64 $end
$upscope $end
$scope module uut $end
$upscope $end
$upscope $end
$scope module carry_look_ahead_logic $end
$upscope $end
$scope module half_adder_tb $end
$scope module uut $end
$scope module and1 $end
$upscope $end
$scope module xor1 $end
$upscope $end
$upscope $end
$upscope $end
$scope module slow_or $end
$upscope $end
$scope module spg_block $end
$scope module ha1 $end
$scope module and1 $end
$upscope $end
$scope module xor1 $end
$upscope $end
$upscope $end
$scope module xor1 $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bxz r
bz q
bz p
xo
xn
xm
xl
xk
xj
xi
xh
zg
zf
ze
xd
bz c
bx b
bx a
x`
x_
b0 ^
b0 ]
1\
x[
0Z
xY
xX
xW
xV
bx U
bz T
bz S
zR
bx Q
0P
bx O
bx N
bx M
0L
bx K
bx J
bx I
0H
bx G
bx F
bx E
0D
bx C
bx B
bx A
0@
bx ?
bx >
b0 =
b0 <
1;
bx :
bx 9
bx 8
bx 7
bx 6
05
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
bx ,
bx +
x*
x)
x(
x'
x&
bx %
bx $
bx #
bx "
bx !
$end
#50000
1Z
15
#100000
0\
0Z
0;
05
#150000
1Z
15
#160000
0[
0Y
b0 a
b0 b
0X
b1 ^
b0 6
b0 0
b0 O
b0 +
b0 N
b1 =
#162000
0V
0_
#163000
0W
0`
#200000
0Z
05
#250000
1Z
15
#260000
b1 <
#270000
1[
b1 a
b1 b
1Y
b10 ^
b1000 6
b1 0
b1 O
b111 +
b111 N
b10 =
#272000
1V
1_
#300000
0Z
05
#350000
1Z
15
#370000
b10 <
#380000
0Y
b10 a
b10 b
1X
b11 ^
b0 6
b1111 +
b1111 N
b11 =
#400000
0Z
05
#450000
1Z
15
#480000
b11 <
#490000
0[
b11 a
b11 b
1Y
b100 ^
b1110 6
b10 0
b10 O
b1100 +
b1100 N
b100 =
#492000
0V
0_
#493000
1W
1`
#500000
0Z
05
#550000
1Z
15
#590000
b100 <
#600000
b10 6
b110 0
b110 O
b101 =
0Z
05
